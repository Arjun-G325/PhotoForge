<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PhotoForge Collage Maker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://docs.opencv.org/4.11.0/opencv.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background-color: #222;
            display: flex;
            flex-direction: column;
            height: 100vh;
            justify-content: space-between;
            align-items: center;
        }
        
        .toolbar {
            background-color: #333;
            display: flex;
            align-items: center;
            border: 2px solid #444;
            width: 100%;
            padding: 5px;
            height: 60px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .icon-grid, .icon-grid-right {
            display: flex;
            gap: 10px;
            margin-left: 10px;
        }

        .icon-grid label {
            color: #ffffff;
            font-weight: bold;
            font-size: 14px;
        }

        .toolbar button {
            background: none;
            border: none;
            cursor: pointer;
            position: relative;
            font-size: 20px;
            color: white;
        }

        .toolbar button:hover {
            background: #45a049;
        }

        .tooltip {
            visibility: hidden;
            background-color: #1e90ff;
            color: white;
            text-align: center;
            padding: 4px 8px;
            border-radius: 4px;
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 10px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0px 0px 10px rgba(30, 144, 255, 0.8);
            z-index: 1000;
        }

        .toolbar button:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        .partition {
            width: 2px;
            height: 40px;
            background-color: #555;
            margin: 0 15px;
        }
        /* Add to the style section */
        .text-box {
    resize: both;
    overflow: auto;
    min-width: 100px;
    min-height: 30px;
}
.dimension-buttons {
    display: flex;
    gap: 5px;
    margin-top: 5px;
}

.dimension-buttons button {
    flex: 1;
    padding: 3px;
    font-size: 11px;
}
.text-box::-webkit-resizer {
    background-color: #4285f4;
    width: 12px;
    height: 12px;
    border-radius: 2px;
    border: 1px solid white;
}
.text-box {
    position: absolute;
    min-width: 100px;
    min-height: 30px;
    background: rgba(0, 0, 0, 0.5);
    color: white;
    font-size: 20px;
    border: 1px dashed #ccc;
    padding: 5px;
    outline: none;
    font-family: Arial, sans-serif;
    z-index: 100;
    cursor: move;
    resize: both;
    overflow: auto;
}

.text-box.selected {
    border: 2px solid yellow;
}

.text-settings-popup {
    position: fixed;
    top: 80px;
    right: 20px;
    background: #333;
    color: white;
    border: 1px solid #888;
    padding: 10px;
    border-radius: 6px;
    font-size: 12px;
    z-index: 999;
    display: none;
    flex-direction: column;
    gap: 8px;
    width: 200px;
}

.text-settings-popup label {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.text-settings-popup input[type="color"],
.text-settings-popup input[type="number"],
.text-settings-popup select {
    margin-left: 5px;
    background: #444;
    color: white;
    border: none;
    padding: 3px 6px;
    border-radius: 4px;
}

.text-settings-popup button {
    background: #555;
    color: white;
    border: none;
    padding: 5px;
    border-radius: 4px;
    cursor: pointer;
}

.text-settings-popup button:hover {
    background: #666;
}

        .size-input-container {
            display: flex;
            align-items: center;
            gap: 3px;
            color: white;
            font-size: 12px;
        }

        .size-input {
            width: 50px;
            padding: 3px;
            text-align: right;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            background-color: #555;
            color: white;
            appearance: textfield;
        }

        .content {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        .crop-rectangle {
    position: absolute;
    border: 2px dashed yellow;
    background-color: rgba(255, 255, 0, 0.2);
    pointer-events: none;
    z-index: 40;
}

        #collage-container {
            width: 90vw;
            height: 75vh;
            position: relative;
            background: #444;
            border: 2px solid #555;
            overflow: hidden;
        }

        #collageContainer img {
            width: 100%;
            height: auto;
        }
        
        .collage-image {
            position: absolute;
            border: 2px solid #ccc;
            cursor: grab;
            max-width: none;
            transition: filter 0.3s ease;
            transform-origin: center center;
            contain: layout style paint;
        }

        .resize-handles-container {
    pointer-events: none;
    z-index: 20;
    transform: none !important;

}

.resize-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    background: #4285f4;
    border: 2px solid white;
    border-radius: 50%;
    z-index: 30;
    pointer-events: auto;
    transform: translate(-50%, -50%);
    transition: all 0.1s ease;
}

.resize-handle.nw {
    top: 0;
    left: 0;
    cursor: nw-resize;
}

.resize-handle.ne {
    top: 0;
    right: 0;
    cursor: ne-resize;
    transform: translate(50%, -50%);
}

.resize-handle.sw {
    bottom: 0;
    left: 0;
    cursor: sw-resize;
    transform: translate(-50%, 50%);
}

.resize-handle.se {
    bottom: 0;
    right: 0;
    cursor: se-resize;
    transform: translate(50%, 50%);
}

.resize-handle:active {
    transform: scale(1.3);
    background: #1a73e8;
}
.tilt-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    background: #ff9800;
    border: 2px solid white;
    border-radius: 50%;
    z-index: 30;
    pointer-events: auto;
    transform: translate(-50%, -50%);
    transition: all 0.1s ease;
}

.tilt-handle.top {
    top: 0;
    left: 50%;
    cursor: ns-resize;
}

.tilt-handle.right {
    top: 50%;
    right: 0;
    cursor: ew-resize;
}

.tilt-handle.bottom {
    bottom: 0;
    left: 50%;
    cursor: ns-resize;
}
.dimension-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin: 10px 0;
    padding: 10px;
    background: #444;
    border-radius: 4px;
}

.dimension-controls label {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.dimension-controls input[type="number"] {
    width: 60px;
    margin-left: 5px;
}
.tilt-handle.left {
    top: 50%;
    left: 0;
    cursor: ew-resize;
}
        .selected {
            border: 3px solid yellow !important;
            z-index: 5;
        }

        .template-box {
            border: 1px dashed #aaa;
            min-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #777;
            font-style: italic;
        }
        .drawing-canvas {
    position: absolute;
    pointer-events: none;
    z-index: 5;
    border: 2px solid transparent;
}

.selected + .drawing-canvas {
    border-color: yellow;
}

#drawingColor {
    border: none;
    background: none;
    padding: 0;
    margin: 0 5px;
}

#brushSize {
    margin: 0 5px;
    background: #555;
    height: 4px;
}
    </style>
</head>

<body>

<div class="toolbar">
    <div class="icon-grid">
        <button onclick="goHome()"><i class="fa-solid fa-house"></i><span class="tooltip">Home</span></button>
        <button onclick="openImages()"><i class="fa-regular fa-folder-open"></i><span class="tooltip">Open</span></button>
        <button onclick="downloadCollage()"><i class="fa-regular fa-floppy-disk"></i><span class="tooltip">Save</span></button>
        <button onclick="deleteSelectedImage()"><i class="fa-regular fa-trash-can"></i><span class="tooltip">Delete</span></button>
        <button onclick="enableResize()"><i class="fa-solid fa-expand"></i><span class="tooltip">Resize</span></button>
        <button onclick="disableResize()"><i class="fa-solid fa-compress"></i><span class="tooltip">Disable Resize</span></button>
    </div>
    
    <div class="partition"></div>

    <div class="icon-grid">
        <button onclick="cropSelectedImage()"><i class="fa-solid fa-crop-simple"></i><span class="tooltip">Crop</span></button>
        <button onclick="rotateSelected(-90)"><i class="fa-solid fa-rotate-left"></i><span class="tooltip">Rotate Left</span></button>
        <button onclick="rotateSelected(90)"><i class="fa-solid fa-rotate-right"></i><span class="tooltip">Rotate Right</span></button>
        <button onclick="flipSelected('X')"><i class="fa-solid fa-arrows-left-right"></i><span class="tooltip">Flip Horizontally</span></button>
        <button onclick="flipSelected('Y')"><i class="fa-solid fa-arrows-up-down"></i><span class="tooltip">Flip Vertically</span></button>
        <button onclick="enableTilt()"><i class="fa-solid fa-sliders"></i><span class="tooltip">Tilt</span></button>
    </div>

    <div class="partition"></div>

    <div class="icon-grid">
        <button onclick="applyFilter('grayscale')"><i class="fa-solid fa-adjust"></i><span class="tooltip">Black & White</span></button>
        <button onclick="applyFilter('sepia')"><i class="fa-solid fa-tint"></i><span class="tooltip">Sepia</span></button>
        <button onclick="applyFilter('blur')"><i class="fa-solid fa-smog"></i><span class="tooltip">Blur</span></button>
        <button onclick="addTextBox()"><i class="fa-solid fa-font"></i><span class="tooltip">Add Text</span></button>
    <button onclick="toggleTextSettings()"><i class="fa-solid fa-gear"></i><span class="tooltip">Text Settings</span></button>
    </div>
    <div class="partition"></div>

    <div class="icon-grid">
        <button onclick="enableDrawing()"><i class="fa-solid fa-paintbrush"></i><span class="tooltip">Draw</span></button>
        <button onclick="enableEraser()"><i class="fa-solid fa-eraser"></i><span class="tooltip">Eraser</span></button>
        <button onclick="disableDrawing()"><i class="fa-solid fa-ban"></i><span class="tooltip">Stop Drawing</span></button>
        <input type="color" id="drawingColor" value="#ff0000" title="Drawing Color" style="width: 30px; height: 30px; cursor: pointer;">
        <input type="range" id="brushSize" min="1" max="50" value="5" title="Brush Size" style="width: 60px;">
    
    </div>
</div>

<label for="templateSelect">Choose a template:</label>
<select id="templateSelect">
    <option value="">-- Select a template --</option>
    <option value="template1">Modern Frame (White Border)</option>
    <option value="template2">Colorful Floating Frames</option>
    <option value="template3">Instagram Grid</option>
    <option value="template4">Photo Strip</option>
    <option value="template12">Geometric Gradient Grid</option>
    <option value="template6">Vintage Polaroid Mix</option>
    <option value="template7">Modern Grid with Accent Colors</option>
    <option value="template8">Symmetrical Grid</option>
    <option value="template15">Minimalist White Space</option>
    <option value="template16">Bold Color Blocks</option>
    <option value="template13">Minimalist Two-Column with Gradient Background</option>
    <option value="template14">Geometric Color Blocks</option>
    <option value="template17">Asymmetrical Grid with Neutral Colors</option>
</select>

<div id="collageContainer" style="margin-top: 20px;"></div>

<!-- Controls Container -->
<div style="display: flex; flex-direction: row; gap: 16px; align-items: center; flex-wrap: wrap; margin-top: 16px;">

    <!-- Brightness -->
    <div style="display: flex; align-items: center; gap: 4px;">
        <i class="fa-solid fa-sun" style="color: white; font-size: 14px;" title="Brightness"></i>
        <input type="range" min="0" max="200" value="100"
            id="brightnessSlider"
            style="width: 80px; height: 4px;"
            oninput="brightnessValue = this.value; updateAdvancedFilters();">
    </div>

    <!-- Contrast -->
    <div style="display: flex; align-items: center; gap: 4px;">
        <i class="fa-solid fa-eye" style="color: white; font-size: 14px;" title="Contrast"></i>
        <input type="range" min="0" max="200" value="100"
            id="contrastSlider"
            style="width: 80px; height: 4px;"
            oninput="contrastValue = this.value; updateAdvancedFilters();">
    </div>

    <!-- Saturation -->
    <div style="display: flex; align-items: center; gap: 4px;">
        <i class="fa-solid fa-wand-magic-sparkles" style="color: white; font-size: 14px;" title="Saturation"></i>
        <input type="range" min="0" max="200" value="100"
            id="saturationSlider"
            style="width: 80px; height: 4px;"
            oninput="saturationValue = this.value; updateAdvancedFilters();">
    </div>
</div>

<div class="content">
    <div id="collage-container"></div>
</div>

<script>
    const collageContainer = document.getElementById('collage-container');
    let selectedImage = null;
    let brightnessValue = 100;
    let contrastValue = 100;
    let saturationValue = 100;
    let isResizingEnabled = false;
    let resizeHandles = [];
    let isResizing = false;
    let resizeDirection = null;
    let startX, startY, startWidth, startHeight, startLeft, startTop;
   
    let isDrawingEnabled = false;
    let isEraserEnabled = false;
let isDrawing = false;
let lastX = 0;
let lastY = 0;
let currentColor;
let brushSize;
let currentDrawingCtx = null;
document.addEventListener("DOMContentLoaded", function() {
    // Initialize from UI controls
    currentColor = document.getElementById('drawingColor').value;
    brushSize = parseInt(document.getElementById('brushSize').value);
    
    // Set up event listeners for controls
    updateBrushSettings();
});

document.addEventListener("DOMContentLoaded", function () {
        const templateSelect = document.getElementById("templateSelect");
        const collageContainer = document.getElementById("collage-container");
        

        function createTemplate(templateName) {
            collageContainer.innerHTML = "";

            if (templateName === "template1") {
                // Modern Frame (White border)
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: white; padding: 20px; box-sizing: border-box;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; height: 100%;">
                            <div class="template-box" style="background: #f5f5f5; border: 15px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">Drop Image Here</div>
                            <div class="template-box" style="background: #f5f5f5; border: 15px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">Drop Image Here</div>
                            <div class="template-box" style="background: #f5f5f5; border: 15px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">Drop Image Here</div>
                            <div class="template-box" style="background: #f5f5f5; border: 15px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">Drop Image Here</div>
                        </div>
                    </div>`;
            } else if (templateName === "template2") {
    // Colorful floating frames
    collageContainer.innerHTML = `
        <div style="position: relative; width: 100%; height: 100%; background: linear-gradient(45deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%); display: flex; flex-wrap: wrap; justify-content: center; align-content: center; gap: 30px; padding: 20px;">
            <div class="template-box" style="width: 40%; height: 40%; background: white; border: 12px solid white; box-shadow: 0 15px 25px rgba(0,0,0,0.2), 0 0 0 8px #ff6b6b, 0 0 0 12px white;">Drop Image Here</div>
            <div class="template-box" style="width: 40%; height: 40%; background: white; border: 12px solid white; box-shadow: 0 15px 25px rgba(0,0,0,0.2), 0 0 0 8px #4ecdc4, 0 0 0 12px white;">Drop Image Here</div>
            <div class="template-box" style="width: 40%; height: 40%; background: white; border: 12px solid white; box-shadow: 0 15px 25px rgba(0,0,0,0.2), 0 0 0 8px #ffd166, 0 0 0 12px white;">Drop Image Here</div>
            <div class="template-box" style="width: 40%; height: 40%; background: white; border: 12px solid white; box-shadow: 0 15px 25px rgba(0,0,0,0.2), 0 0 0 8px #06d6a0, 0 0 0 12px white;">Drop Image Here</div>
        </div>`;
} else if (templateName === "template3") {
                // Instagram Grid
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #fafafa; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 2px;">
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                        <div class="template-box" style="background: #e0e0e0;">Drop Image Here</div>
                    </div>`;
            } else if (templateName === "template4") {
                // Photo Strip 
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #333; display: flex; justify-content: center; align-items: center; padding: 20px;">
                        <div style="display: flex; height: 80%; gap: 15px;">
                            <div class="template-box" style="width: 20%; background: #f5f5f5; border: 5px solid white; box-shadow: 0 0 0 10px #333;">Drop Image Here</div>
                            <div class="template-box" style="width: 20%; background: #f5f5f5; border: 5px solid white; box-shadow: 0 0 0 10px #333;">Drop Image Here</div>
                            <div class="template-box" style="width: 20%; background: #f5f5f5; border: 5px solid white; box-shadow: 0 0 0 10px #333;">Drop Image Here</div>
                            <div class="template-box" style="width: 20%; background: #f5f5f5; border: 5px solid white; box-shadow: 0 0 0 10px #333;">Drop Image Here</div>
                            <div class="template-box" style="width: 20%; background: #f5f5f5; border: 5px solid white; box-shadow: 0 0 0 10px #333;">Drop Image Here</div>
                        </div>
                    </div>`;
            } else if (templateName === "template12") {
                // Geometric Gradient Grid
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 10px; padding: 10px;">
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">Drop Image Here</div>
                    </div>`;
            } else if (templateName === "template15") {
                // Minimalist White Space
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #f9f9f9; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 20px; padding: 40px;">
                        <div class="template-box" style="background: white; border: 1px solid #eee; box-shadow: 0 2px 8px rgba(0,0,0,0.03);">Drop Image Here</div>
                        <div class="template-box" style="background: white; border: 1px solid #eee; box-shadow: 0 2px 8px rgba(0,0,0,0.03);">Drop Image Here</div>
                        <div class="template-box" style="background: white; border: 1px solid #eee; box-shadow: 0 2px 8px rgba(0,0,0,0.03);">Drop Image Here</div>
                        <div class="template-box" style="background: white; border: 1px solid #eee; box-shadow: 0 2px 8px rgba(0,0,0,0.03); grid-column: span 3; height: 60%;">Drop Image Here</div>
                    </div>`;
            } else if (templateName === "template16") {
                // Bold Color Blocks
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #1a1a2e; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 15px; padding: 15px;">
                        <div class="template-box" style="background: #16213e; border: 2px solid #0f3460;">Drop Image Here</div>
                        <div class="template-box" style="background: #0f3460; border: 2px solid #16213e;">Drop Image Here</div>
                        <div class="template-box" style="background: #533483; border: 2px solid #16213e;">Drop Image Here</div>
                        <div class="template-box" style="background: #e94560; border: 2px solid #16213e;">Drop Image Here</div>
                    </div>`;
            } else if (templateName === "template6") {
                // Vintage Polaroid Mix 
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #e8e8e8; display: flex; flex-wrap: wrap; align-content: flex-start; padding: 20px; gap: 30px;">
                        <div style="position: relative; width: 30%; height: 40%; background: white; padding: 15px 15px 60px 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); transform: rotate(-3deg);">
                            <div class="template-box" style="width: 100%; height: 100%; background: #f5f5f5;">Drop Image Here</div>
                            <div contenteditable="true" style="position: absolute; bottom: 15px; left: 15px; right: 15px; height: 30px; font-family: 'Courier New', monospace; font-size: 14px; color: #888; outline: none;">Click to add caption</div>
                        </div>
                        <div style="position: relative; width: 30%; height: 30%; background: white; padding: 15px 15px 50px 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); transform: rotate(2deg);">
                            <div class="template-box" style="width: 100%; height: 100%; background: #f5f5f5;">Drop Image Here</div>
                            <div contenteditable="true" style="position: absolute; bottom: 15px; left: 15px; right: 15px; height: 20px; font-family: 'Courier New', monospace; font-size: 12px; color: #888; outline: none;">Click to add caption</div>
                        </div>
                        <div style="position: relative; width: 35%; height: 35%; background: white; padding: 15px 15px 70px 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); transform: rotate(-1deg);">
                            <div class="template-box" style="width: 100%; height: 100%; background: #f5f5f5;">Drop Image Here</div>
                            <div contenteditable="true" style="position: absolute; bottom: 15px; left: 15px; right: 15px; height: 40px; font-family: 'Courier New', monospace; font-size: 16px; color: #888; outline: none;">Click to add caption</div>
                        </div>
                    </div>`;
            } else if (templateName === "template7") {
                // Modern Grid with Accent Colors
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #f8f9fa; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 15px; padding: 15px;">
                        <div class="template-box" style="background: #ffffff; border: 2px solid #e63946; box-shadow: 0 2px 8px rgba(230, 57, 70, 0.2);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 2px solid #457b9d; box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 2px solid #1d3557; box-shadow: 0 2px 8px rgba(29, 53, 87, 0.2);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 2px solid #a8dadc; box-shadow: 0 2px 8px rgba(168, 218, 220, 0.2);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 2px solid #f1faee; box-shadow: 0 2px 8px rgba(241, 250, 238, 0.2);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 2px solid #e63946; box-shadow: 0 2px 8px rgba(230, 57, 70, 0.2);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 2px solid #457b9d; box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 2px solid #1d3557; box-shadow: 0 2px 8px rgba(29, 53, 87, 0.2);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 2px solid #a8dadc; box-shadow: 0 2px 8px rgba(168, 218, 220, 0.2);">Drop Image Here</div>
                    </div>`;
            } else if (templateName === "template8") {
                // Symmetrical Grid 
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #e0e0e0; display: flex; flex-wrap: wrap; justify-content: space-around; padding: 20px; gap: 20px;">
                        <div style="width: 30%; height: 40%; background: #fff3e6; padding: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); border: 10px solid #e0aaff; transform: rotate(5deg);">
                            <div class="template-box" style="width: 100%; height: 100%; background: #f5f5f5;">Drop Image Here</div>
                        </div>
                        <div style="width: 30%; height: 40%; background: #fff3e6; padding: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); border: 10px solid #e0aaff; transform: rotate(-3deg);">
                            <div class="template-box" style="width: 100%; height: 100%; background: #f5f5f5;">Drop Image Here</div>
                        </div>
                    </div>`;
            } else if (templateName === "template13") {
                // Minimalist Two-Column with Gradient Background 
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 30px;">
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border: none; box-shadow: 0 4px 20px rgba(0,0,0,0.08);">Drop Image Here</div>
                        <div class="template-box" style="background: rgba(255,255,255,0.9); border: none; box-shadow: 0 4px 20px rgba(0,0,0,0.08);">Drop Image Here</div>
                    </div>`;
            } else if (templateName === "template14") {
                // Geometric Color Blocks
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #2b2d42; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 10px; padding: 10px;">
                        <div class="template-box" style="background: #8d99ae; grid-column: span 2; border: none;">Drop Image Here</div>
                        <div class="template-box" style="background: #ef233c; border: none;">Drop Image Here</div>
                        <div class="template-box" style="background: #d90429; border: none;">Drop Image Here</div>
                        <div class="template-box" style="background: #edf2f4; grid-column: span 2; border: none;">Drop Image Here</div>
                    </div>`;
            } else if (templateName === "template17") {
                // Asymmetrical Grid with Neutral Colors
                collageContainer.innerHTML = `
                    <div style="position: relative; width: 100%; height: 100%; background: #f1f1f1; display: grid; grid-template-columns: 2fr 1fr; grid-template-rows: 1fr 1fr; gap: 15px; padding: 15px;">
                        <div class="template-box" style="background: #ffffff; grid-row: span 2; border: 1px solid #ddd; box-shadow: 0 3px 10px rgba(0,0,0,0.05);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 1px solid #ddd; box-shadow: 0 3px 10px rgba(0,0,0,0.05);">Drop Image Here</div>
                        <div class="template-box" style="background: #ffffff; border: 1px solid #ddd; box-shadow: 0 3px 10px rgba(0,0,0,0.05);">Drop Image Here</div>
                    </div>`;
            }

        }


        templateSelect.addEventListener("change", function () {
            const selectedTemplate = templateSelect.value;
            createTemplate(selectedTemplate);
        });
    });

    function goHome() {
        window.close();
    }
    function enableEraser() {
    if (!selectedImage) {
        alert("Please select an image first");
        return;
    }
    
    if (isCropping) resetCrop();
    if (isResizingEnabled) disableResize();
    
    isEraserEnabled = true;
    isDrawingEnabled = false;
    
    const drawingCanvas = selectedImage.nextElementSibling;
    if (!drawingCanvas || !drawingCanvas.classList.contains('drawing-canvas')) {
        alert("No drawing to erase. Please draw something first.");
        isEraserEnabled = false;
        return;
    }
    
    drawingCanvas.style.pointerEvents = 'auto';
    document.body.style.cursor = 'crosshair';
    
    drawingCanvas.addEventListener('mousedown', startErasing);
    drawingCanvas.addEventListener('mousemove', erase);
    drawingCanvas.addEventListener('mouseup', stopErasing);
    drawingCanvas.addEventListener('mouseout', stopErasing);
}

function startErasing(e) {
    if (!isEraserEnabled || !selectedImage) return;
    
    isDrawing = true;
    const rect = e.target.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    
    // Get the drawing canvas
    const drawingCanvas = selectedImage.nextElementSibling;
    if (!drawingCanvas || !drawingCanvas.classList.contains('drawing-canvas')) return;
    
    // Transform coordinates
    const transformed = transformCoordinates(x, y, selectedImage);
    lastX = transformed.x;
    lastY = transformed.y;
    
    eraseAtPosition(lastX, lastY, drawingCanvas);
}

function erase(e) {
    if (!isDrawing || !isEraserEnabled || !selectedImage) return;
    
    const rect = e.target.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    
    // Get the drawing canvas
    const drawingCanvas = selectedImage.nextElementSibling;
    if (!drawingCanvas || !drawingCanvas.classList.contains('drawing-canvas')) return;
    
    // Transform coordinates
    const transformed = transformCoordinates(x, y, selectedImage);
    x = transformed.x;
    y = transformed.y;
    
    eraseLine(lastX, lastY, x, y, drawingCanvas);
    
    lastX = x;
    lastY = y;
}

function eraseAtPosition(x, y, canvas) {
    const ctx = canvas.getContext('2d');
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(x, y, brushSize/2, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
}

function eraseLine(x1, y1, x2, y2, canvas) {
    const ctx = canvas.getContext('2d');
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.globalCompositeOperation = 'source-over';
}
function stopErasing() {
    isDrawing = false;
}

function disableEraser() {
    if (!selectedImage) return;
    
    const drawingCanvas = selectedImage.nextElementSibling;
    if (!drawingCanvas) return;
    
    isEraserEnabled = false;
    document.body.style.cursor = '';
    drawingCanvas.style.pointerEvents = 'none';
    
    drawingCanvas.removeEventListener('mousedown', startErasing);
    drawingCanvas.removeEventListener('mousemove', erase);
    drawingCanvas.removeEventListener('mouseup', stopErasing);
    drawingCanvas.removeEventListener('mouseout', stopErasing);
}
    function initializeDrawingCanvas() {
    // Create canvas for drawing
    drawingCanvas = document.createElement('canvas');
    drawingCanvas.id = 'drawing-canvas';
    drawingCanvas.style.position = 'absolute';
    drawingCanvas.style.top = '0';
    drawingCanvas.style.left = '0';
    drawingCanvas.style.zIndex = '10';
    drawingCanvas.style.pointerEvents = 'none';
    
    // Set canvas size to match container
    drawingCanvas.width = collageContainer.offsetWidth;
    drawingCanvas.height = collageContainer.offsetHeight;
    
    collageContainer.appendChild(drawingCanvas);
    drawingCtx = drawingCanvas.getContext('2d');
    
    // Set initial drawing styles
    drawingCtx.strokeStyle = currentColor;
    drawingCtx.lineWidth = brushSize;
    drawingCtx.lineJoin = 'round';
    drawingCtx.lineCap = 'round';
    
    // Watch for color and brush size changes
    document.getElementById('drawingColor').addEventListener('input', function() {
        currentColor = this.value;
        drawingCtx.strokeStyle = currentColor;
    });
    
    document.getElementById('brushSize').addEventListener('input', function() {
        brushSize = this.value;
        drawingCtx.lineWidth = brushSize;
    });
}

function enableDrawing() {
    if (!selectedImage) {
        alert("Please select an image first");
        return;
    }
    
    if (isCropping) resetCrop();
    if (isResizingEnabled) disableResize();
    if (isEraserEnabled) disableEraser();
    
    isDrawingEnabled = true;
    const drawingCanvas = selectedImage.nextElementSibling;
    if (!drawingCanvas || !drawingCanvas.classList.contains('drawing-canvas')) {
        // Create new canvas if it doesn't exist
        const newCanvas = document.createElement('canvas');
        newCanvas.className = 'drawing-canvas';
        newCanvas.width = selectedImage.offsetWidth;
        newCanvas.height = selectedImage.offsetHeight;
        newCanvas.style.position = 'absolute';
        newCanvas.style.left = selectedImage.style.left;
        newCanvas.style.top = selectedImage.style.top;
        newCanvas.style.width = selectedImage.style.width;
        newCanvas.style.height = selectedImage.style.height;
        newCanvas.style.pointerEvents = 'none';
        selectedImage.parentNode.insertBefore(newCanvas, selectedImage.nextSibling);
        currentDrawingCanvas = newCanvas;
    } else {
        currentDrawingCanvas = drawingCanvas;
    }
    
    // Set up drawing context
    currentDrawingCtx = currentDrawingCanvas.getContext('2d');
    currentDrawingCtx.strokeStyle = currentColor;
    currentDrawingCtx.lineWidth = brushSize;
    currentDrawingCtx.lineJoin = 'round';
    currentDrawingCtx.lineCap = 'round';
    
    currentDrawingCanvas.style.pointerEvents = 'auto';
    document.body.style.cursor = 'crosshair';
    
    currentDrawingCanvas.addEventListener('mousedown', startDrawing);
    currentDrawingCanvas.addEventListener('mousemove', draw);
    currentDrawingCanvas.addEventListener('mouseup', stopDrawing);
    currentDrawingCanvas.addEventListener('mouseout', stopDrawing);
}
function transformCoordinates(x, y, img) {
    const rotation = parseInt(img.dataset.rotation) || 0;
    const flipX = parseInt(img.dataset.flipX) || 1;
    const flipY = parseInt(img.dataset.flipY) || 1;
    
    const width = img.offsetWidth;
    const height = img.offsetHeight;
    
    // Get the drawing canvas
    const drawingCanvas = img.nextElementSibling;
    if (!drawingCanvas || !drawingCanvas.classList.contains('drawing-canvas')) {
        return { x, y };
    }
    
    
    const scaleX = drawingCanvas.width / width;
    const scaleY = drawingCanvas.height / height;
    
    // Create a virtual canvas to calculate transformations
    const virtualCanvas = document.createElement('canvas');
    virtualCanvas.width = width;
    virtualCanvas.height = height;
    const ctx = virtualCanvas.getContext('2d');
    
    // Apply the same transformations as the image
    ctx.translate(width/2, height/2);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(flipX, flipY);
    ctx.translate(-width/2, -height/2);
    
    
    const matrix = ctx.getTransform().inverse();
    
   
    const transformedX = matrix.a * x + matrix.c * y + matrix.e;
    const transformedY = matrix.b * x + matrix.d * y + matrix.f;
    
    
    return { 
        x: transformedX * scaleX, 
        y: transformedY * scaleY 
    };
}
function disableDrawing() {
    if (!selectedImage) return;
    
    const drawingCanvas = selectedImage.nextElementSibling;
    if (!drawingCanvas) return;
    
    isDrawingEnabled = false;
    isDrawing = false;
    document.body.style.cursor = '';
    drawingCanvas.style.pointerEvents = 'none';
    
    drawingCanvas.removeEventListener('mousedown', startDrawing);
    drawingCanvas.removeEventListener('mousemove', draw);
    drawingCanvas.removeEventListener('mouseup', stopDrawing);
    drawingCanvas.removeEventListener('mouseout', stopDrawing);
}

function startDrawing(e) {
    if (!isDrawingEnabled || !selectedImage) return;
    
    isDrawing = true;
    const rect = e.target.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    
    // Get the drawing canvas 
    const drawingCanvas = selectedImage.nextElementSibling;
    if (!drawingCanvas || !drawingCanvas.classList.contains('drawing-canvas')) return;
    
    // Transform coordinates based on image state
    const transformed = transformCoordinates(x, y, selectedImage);
    lastX = transformed.x;
    lastY = transformed.y;
    
    // Set up drawing context
    const ctx = drawingCanvas.getContext('2d');
    ctx.beginPath();
    ctx.arc(lastX, lastY, brushSize/2, 0, Math.PI * 2);
    ctx.fill();
}

function draw(e) {
    if (!isDrawing || !isDrawingEnabled || !selectedImage) return;
    
    const rect = e.target.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    
    // Get the drawing canvas
    const drawingCanvas = selectedImage.nextElementSibling;
    if (!drawingCanvas || !drawingCanvas.classList.contains('drawing-canvas')) return;
    
    // Transform coordinates
    const transformed = transformCoordinates(x, y, selectedImage);
    x = transformed.x;
    y = transformed.y;
    
    const ctx = drawingCanvas.getContext('2d');
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();
    
    lastX = x;
    lastY = y;
}

function stopDrawing() {
    isDrawing = false;
}
function clearDrawing() {
    if (drawingCanvas) {
        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }
}
function updateBrushSettings() {
    const colorInput = document.getElementById('drawingColor');
    const sizeInput = document.getElementById('brushSize');
    
    // Ensure we have valid elements
    if (!colorInput || !sizeInput) return;
    
    // Remove old event listeners
    colorInput.oninput = null;
    sizeInput.oninput = null;
    
    // Force sync with current values
    currentColor = colorInput.value;
    brushSize = parseInt(sizeInput.value);
    
    // Update drawing context if exists
    if (currentDrawingCtx) {
        currentDrawingCtx.strokeStyle = currentColor;
        currentDrawingCtx.lineWidth = brushSize;
    }
    
    // Add new event listeners
    colorInput.addEventListener('input', function() {
        currentColor = this.value;
        if (currentDrawingCtx) {
            currentDrawingCtx.strokeStyle = currentColor;
        }
    });
    
    sizeInput.addEventListener('input', function() {
        brushSize = parseInt(this.value);
        if (currentDrawingCtx) {
            currentDrawingCtx.lineWidth = brushSize;
        }
    });
}
    function openImages() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.multiple = true;

        input.onchange = (event) => {
            const files = event.target.files;
            for (const file of files) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.classList.add('collage-image');
                    img.dataset.rotation = '0';
                    img.dataset.flipX = '1';
                    img.dataset.flipY = '1';
                    img.style.left = Math.random() * 500 + "px";
                    img.style.top = Math.random() * 300 + "px";
                    img.style.width = "200px";
                    img.style.height = "auto";

                    collageContainer.appendChild(img);

                    makeDraggable(img);
                    img.onclick = (e) => {
                        e.stopPropagation();
                        selectImage(img);
                    };
                };
                reader.readAsDataURL(file);
            }
        };
        input.click();
    }

    function updateAdvancedFilters() {
        if (!selectedImage) return;

        const filterString = `
            brightness(${brightnessValue}%)
            contrast(${contrastValue}%)
            saturate(${saturationValue}%)
        `.trim();

        selectedImage.style.filter = filterString;
    }
    let isCropping = false;
let cropStartX, cropStartY;
let cropRect = null;
let wasDraggable = false;
function cropSelectedImage() {
    if (!selectedImage) {
        alert("Please select an image first");
        return;
    }

    // Disable resizing if active
    if (isResizingEnabled) {
        disableResize();
    }
    if (cropRect) {
        resetCrop();
        return;
    }

    // Store original draggable state and disable dragging
    wasDraggable = selectedImage.hasAttribute('draggable');
    selectedImage.removeAttribute('draggable');
    selectedImage.style.pointerEvents = 'none';

    // Set cropping mode
    isCropping = true;

    // Change cursor to indicate cropping mode
    document.body.style.cursor = 'crosshair';

    // Add event listeners for cropping - listen on the whole document
    document.addEventListener('mousedown', startCrop);
    document.addEventListener('mousemove', drawCropArea);
    document.addEventListener('mouseup', endCrop);
}
// Add these variables at the top with other variables
let selectedTextBox = null;
let isTextSettingsOpen = false;
let textSettingsPopup = null;

// Add these functions to the script
function createTextSettingsPopup() {
    if (!textSettingsPopup) {
        textSettingsPopup = document.createElement('div');
        textSettingsPopup.className = 'text-settings-popup';
        textSettingsPopup.innerHTML = `
    <label>Font:
        <select id="textFontFamily">
             <option value="Arial">Arial</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Tahoma">Tahoma</option>
                    <option value="Trebuchet MS">Trebuchet MS</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Garamond">Garamond</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Brush Script MT">Brush Script</option>
                    <option value="Comic Sans MS">Comic Sans</option>
                    <option value="Impact">Impact</option>
                    <option value="Lucida Console">Lucida Console</option>
                    <option value="Palatino">Palatino</option>
        </select>
    </label>
    <label>Size:
        <input type="number" id="textFontSize" value="20" min="8" max="72">
    </label>
    <label>Color:
        <input type="color" id="textColor" value="#ffffff">
    </label>
    <label>Background:
        <input type="color" id="textBackground" value="#00000080">
    </label>
    <div class="dimension-controls">
        <label>Width (px):
            <input type="number" id="textBoxWidth" value="200" min="50" max="800">
        </label>
        <label>Height (px):
            <input type="number" id="textBoxHeight" value="auto" min="30" max="600">
        </label>
    </div>
    <button onclick="deleteSelectedTextBox()">Delete Text Box</button>
`;
        document.body.appendChild(textSettingsPopup);
        
        // Add event listeners for the settings
        // Add these with the other event listeners
document.getElementById('textBoxWidth').addEventListener('change', function() {
    if (selectedTextBox) {
        selectedTextBox.style.width = this.value + 'px';
    }
});

document.getElementById('textBoxHeight').addEventListener('change', function() {
    if (selectedTextBox) {
        const value = this.value;
        selectedTextBox.style.height = value === 'auto' ? 'auto' : value + 'px';
    }
});
        document.getElementById('textFontFamily').addEventListener('change', function() {
            if (selectedTextBox) {
                selectedTextBox.style.fontFamily = this.value;
            }
        });
        
        document.getElementById('textFontSize').addEventListener('change', function() {
            if (selectedTextBox) {
                selectedTextBox.style.fontSize = this.value + 'px';
            }
        });
        
        document.getElementById('textColor').addEventListener('input', function() {
            if (selectedTextBox) {
                selectedTextBox.style.color = this.value;
            }
        });
        
        document.getElementById('textBackground').addEventListener('input', function() {
            if (selectedTextBox) {
                selectedTextBox.style.backgroundColor = this.value;
            }
        });
    }
}

function toggleTextSettings() {
    if (!textSettingsPopup) {
        createTextSettingsPopup();
    }
    
    isTextSettingsOpen = !isTextSettingsOpen;
    
    if (isTextSettingsOpen) {
        textSettingsPopup.style.display = 'flex';
        // Update controls with current text box values
        if (selectedTextBox) {
            document.getElementById('textFontFamily').value = selectedTextBox.style.fontFamily || 'Arial';
            document.getElementById('textFontSize').value = parseInt(selectedTextBox.style.fontSize) || 20;
            document.getElementById('textColor').value = rgbToHex(selectedTextBox.style.color) || '#ffffff';
            document.getElementById('textBackground').value = rgbToHex(selectedTextBox.style.backgroundColor) || '#00000080';
        }
    } else {
        textSettingsPopup.style.display = 'none';
    }
}

function rgbToHex(rgb) {
    if (!rgb) return '';
    if (rgb.startsWith('#')) return rgb;
    
    const match = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)$/);
    if (!match) return '';
    
    const r = parseInt(match[1]);
    const g = parseInt(match[2]);
    const b = parseInt(match[3]);
    const a = match[4] ? Math.round(parseFloat(match[4]) * 255) : 255;
    
    return '#' + 
        ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1) + 
        (a < 255 ? Math.round(a).toString(16).padStart(2, '0') : '');
}

function addTextBox() {
    const textBox = document.createElement('div');
    textBox.className = 'text-box';
    textBox.contentEditable = true;
    textBox.innerText = 'Double click to edit text';
    textBox.style.left = '100px';
    textBox.style.top = '100px';
    textBox.style.width = '200px';
    textBox.style.height = 'auto';
    textBox.style.minHeight = '30px';
    textBox.style.fontFamily = 'Arial';
    textBox.style.fontSize = '20px';
    textBox.style.color = '#ffffff';
    textBox.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    // Use the dedicated text draggable function
    makeTextDraggable(textBox);
    
    // Rest of the function remains the same...
    textBox.addEventListener('click', function(e) {
        e.stopPropagation();
        selectTextBox(textBox);
    });
    
    textBox.addEventListener('dblclick', function(e) {
        e.stopPropagation();
        const range = document.createRange();
        range.selectNodeContents(textBox);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
    });
    
    collageContainer.appendChild(textBox);
    selectTextBox(textBox);
}

function selectTextBox(textBox) {
    if (selectedTextBox) {
        selectedTextBox.classList.remove('selected');
    }
    
    selectedTextBox = textBox;
    textBox.classList.add('selected');
    
    // Update settings popup if open
    if (isTextSettingsOpen && textSettingsPopup) {
        document.getElementById('textFontFamily').value = textBox.style.fontFamily || 'Arial';
        document.getElementById('textFontSize').value = parseInt(textBox.style.fontSize) || 20;
        document.getElementById('textColor').value = rgbToHex(textBox.style.color) || '#ffffff';
        document.getElementById('textBackground').value = rgbToHex(textBox.style.backgroundColor) || '#00000080';
        
        // Update dimension controls
        document.getElementById('textBoxWidth').value = 
            parseInt(textBox.style.width) || 200;
        document.getElementById('textBoxHeight').value = 
            textBox.style.height === 'auto' ? 'auto' : parseInt(textBox.style.height) || 30;
    }
}

function deleteSelectedTextBox() {
    if (selectedTextBox) {
        selectedTextBox.remove();
        selectedTextBox = null;
    }
    toggleTextSettings(); // Close the popup
}

// Update the document click handler to deselect text boxes when clicking elsewhere
document.addEventListener('click', function(e) {
    if (!e.target.classList.contains('text-box') && 
        !e.target.closest('.text-settings-popup') &&
        !e.target.closest('button[onclick="toggleTextSettings()"]')) {
        if (selectedTextBox) {
            selectedTextBox.classList.remove('selected');
            selectedTextBox = null;
        }
    }
});
function makeTextDraggable(element) {
    let isDragging = false, startX, startY, startLeft, startTop;

    element.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('resize-handle')) return;
        
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(element.style.left) || 0;
        startTop = parseInt(element.style.top) || 0;

        document.addEventListener('mousemove', dragMove);
        document.addEventListener('mouseup', stopDrag);
    });

    function dragMove(e) {
        if (!isDragging) return;
        const newLeft = startLeft + (e.clientX - startX);
        const newTop = startTop + (e.clientY - startY);
        
        element.style.left = newLeft + "px";
        element.style.top = newTop + "px";
    }

    function stopDrag() {
        isDragging = false;
        document.removeEventListener('mousemove', dragMove);
        document.removeEventListener('mouseup', stopDrag);
    }
}
function makeDraggable(element) {
    let isDragging = false, startX, startY, startLeft, startTop;

    element.addEventListener('mousedown', (e) => {
        // Don't start drag if clicking on a resize handle or settings button
        if (e.target.classList.contains('resize-handle') || 
            e.target.closest('.text-settings-popup')) {
            return;
        }
        
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(element.style.left) || 0;
        startTop = parseInt(element.style.top) || 0;

        // Select the element if it's a text box
        if (element.classList.contains('text-box')) {
            selectTextBox(element);
        }

        document.addEventListener('mousemove', dragMove);
        document.addEventListener('mouseup', stopDrag);
    });

    function dragMove(e) {
        if (!isDragging) return;
        const newLeft = startLeft + (e.clientX - startX);
        const newTop = startTop + (e.clientY - startY);
        
        element.style.left = newLeft + "px";
        element.style.top = newTop + "px";
    }

    function stopDrag(e) {
    isDragging = false;
    document.removeEventListener('mousemove', dragMove);
    document.removeEventListener('mouseup', stopDrag);

    // Skip template box snapping and resizing for text boxes
    if (element.classList.contains('text-box')) return;

    // Rest of the original template box snapping code...
    // [Keep the existing template box snapping code for images]
}
}
document.addEventListener('keydown', function(e) {
    // ... existing shortcuts ...
    
    // Add text box shortcuts
    if (e.key === 'Delete' && selectedTextBox) {
        deleteSelectedTextBox();
    }
    if (e.ctrlKey && e.key === 't') {
        e.preventDefault();
        addTextBox();
    }
});

function startCrop(e) {
    if (!isCropping) return;
    
    
    if (e.target.closest('button, .toolbar, .resize-handle')) {
        return;
    }

    e.stopPropagation();
    e.preventDefault();

    // Get container position - use the selected image's offset parent
    const container = selectedImage.offsetParent || collageContainer;
    const containerRect = container.getBoundingClientRect();

    // Calculate coordinates relative to container
    cropStartX = e.clientX - containerRect.left;
    cropStartY = e.clientY - containerRect.top;

    // Create crop rectangle element
    cropRect = document.createElement('div');
    cropRect.className = 'crop-rectangle';
    cropRect.style.left = (cropStartX + container.scrollLeft) + 'px';
    cropRect.style.top = (cropStartY + container.scrollTop) + 'px';
    cropRect.style.width = '0px';
    cropRect.style.height = '0px';
    
    container.appendChild(cropRect);
}

function drawCropArea(e) {
    if (!isCropping || !cropRect) return;

    e.stopPropagation();
    e.preventDefault();

    const container = selectedImage.offsetParent || collageContainer;
    const containerRect = container.getBoundingClientRect();
    const currentX = e.clientX - containerRect.left;
    const currentY = e.clientY - containerRect.top;

    // Calculate dimensions and position
    const width = Math.abs(currentX - cropStartX);
    const height = Math.abs(currentY - cropStartY);
    const left = Math.min(currentX, cropStartX) + container.scrollLeft;
    const top = Math.min(currentY, cropStartY) + container.scrollTop;

    // Update crop rectangle
    cropRect.style.width = width + 'px';
    cropRect.style.height = height + 'px';
    cropRect.style.left = left + 'px';
    cropRect.style.top = top + 'px';
}

function applyCropToImage(cropLeft, cropTop, cropWidth, cropHeight) {
    // Create canvas for cropping the image
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas dimensions to crop size
    canvas.width = cropWidth;
    canvas.height = cropHeight;

    // Calculate image position relative to its container
    const imgRect = selectedImage.getBoundingClientRect();
    const container = selectedImage.offsetParent || collageContainer;
    const containerRect = container.getBoundingClientRect();

    // Calculate source coordinates (relative to image)
    const imgLeft = imgRect.left - containerRect.left + container.scrollLeft;
    const imgTop = imgRect.top - containerRect.top + container.scrollTop;

    const srcX = cropLeft - imgLeft;
    const srcY = cropTop - imgTop;

    // Get actual image dimensions 
    const imgDisplayWidth = imgRect.width;
    const imgDisplayHeight = imgRect.height;
    const imgNaturalWidth = selectedImage.naturalWidth;
    const imgNaturalHeight = selectedImage.naturalHeight;

    // Calculate scale factors
    const scaleX = imgNaturalWidth / imgDisplayWidth;
    const scaleY = imgNaturalHeight / imgDisplayHeight;

    // Calculate source coordinates in original image pixels
    const srcXOriginal = Math.max(0, srcX * scaleX);
    const srcYOriginal = Math.max(0, srcY * scaleY);
    const widthOriginal = Math.min(cropWidth * scaleX, imgNaturalWidth - srcXOriginal);
    const heightOriginal = Math.min(cropHeight * scaleY, imgNaturalHeight - srcYOriginal);

    // Draw the cropped portion
    ctx.drawImage(
        selectedImage,
        srcXOriginal, srcYOriginal,       
        widthOriginal, heightOriginal,    
        0, 0,                            
        cropWidth, cropHeight             
    );

    // Replace image with cropped version
    selectedImage.src = canvas.toDataURL();

    // Update image dimensions and position
    selectedImage.style.width = cropWidth + 'px';
    selectedImage.style.height = 'auto';
    selectedImage.style.left = (cropLeft - container.scrollLeft) + 'px';
    selectedImage.style.top = (cropTop - container.scrollTop) + 'px';

    // Crop the drawing canvas
    const drawingCanvas = selectedImage.nextElementSibling;
    if (drawingCanvas && drawingCanvas.classList.contains('drawing-canvas')) {
        const drawingCtx = drawingCanvas.getContext('2d');
        
        // Create a temporary canvas for the cropped drawing
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = cropWidth;
        tempCanvas.height = cropHeight;
        
        // Calculate the scale factor between drawing canvas and displayed image
        const drawingToDisplayX = drawingCanvas.width / imgDisplayWidth;
        const drawingToDisplayY = drawingCanvas.height / imgDisplayHeight;
        
        // Calculate crop coordinates in drawing canvas space
        const drawingCropX = srcX * drawingToDisplayX;
        const drawingCropY = srcY * drawingToDisplayY;
        const drawingCropWidth = cropWidth * drawingToDisplayX;
        const drawingCropHeight = cropHeight * drawingToDisplayY;
        
        // Draw the cropped portion of the drawing
        tempCtx.drawImage(
            drawingCanvas,
            drawingCropX, drawingCropY,     
            drawingCropWidth, drawingCropHeight, 
            0, 0,                           
            cropWidth, cropHeight           
        );
        
        // Resize the drawing canvas to match the new image size
        drawingCanvas.width = cropWidth;
        drawingCanvas.height = cropHeight;
        drawingCtx.drawImage(tempCanvas, 0, 0);
        
        // Update drawing canvas position and size to match the image
        drawingCanvas.style.left = selectedImage.style.left;
        drawingCanvas.style.top = selectedImage.style.top;
        drawingCanvas.style.width = cropWidth + 'px';
        drawingCanvas.style.height = cropHeight + 'px';
        
        // Reset transformations (they'll be reapplied in applyTransformations)
        drawingCanvas.style.transform = '';
    }
    
    // Reapply any transformations to both image and drawing canvas
    applyTransformations(selectedImage);
}


function endCrop(e) {
    if (!isCropping) return;

    e.stopPropagation();
    e.preventDefault();

    // Reset cursor first
    document.body.style.cursor = '';

    // Remove event listeners
    document.removeEventListener('mousedown', startCrop);
    document.removeEventListener('mousemove', drawCropArea);
    document.removeEventListener('mouseup', endCrop);

    if (!cropRect) {
        resetCrop();
        return;
    }

    // Get crop coordinates
    const cropRectStyle = window.getComputedStyle(cropRect);
    const left = parseInt(cropRectStyle.left);
    const top = parseInt(cropRectStyle.top);
    const width = parseInt(cropRectStyle.width);
    const height = parseInt(cropRectStyle.height);

    // Remove the visual crop rectangle
    if (cropRect.parentNode) {
        cropRect.parentNode.removeChild(cropRect);
    }
    cropRect = null;

    // Apply the actual crop if area is valid
    if (width > 10 && height > 10) {
        applyCropToImage(left, top, width, height);
    }

    resetCrop();
}

function resetCrop() {
    // Reset cursor
    document.body.style.cursor = '';
    
    // Restore original draggable state
    if (wasDraggable) {
        selectedImage.setAttribute('draggable', 'true');
    }
    selectedImage.style.pointerEvents = 'auto';
    
    // Clean up any remaining crop rectangle
    if (cropRect && cropRect.parentNode) {
        cropRect.parentNode.removeChild(cropRect);
    }
    
    // Reset variables
    isCropping = false;
    cropRect = null;
    wasDraggable = false;
    
    // Remove all event listeners
    document.removeEventListener('mousedown', startCrop);
    document.removeEventListener('mousemove', drawCropArea);
    document.removeEventListener('mouseup', endCrop);
}
function resizeImageToBox(img, width, height) {
    img.style.width = width + 'px';
    img.style.height = height + 'px';
}

function makeDraggable(element) {
    let isDragging = false, startX, startY, startLeft, startTop;

    element.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('resize-handle')) return;
        
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(element.style.left) || 0;
        startTop = parseInt(element.style.top) || 0;

        document.addEventListener('mousemove', dragMove);
        document.addEventListener('mouseup', stopDrag);
    });

    function dragMove(e) {
        if (!isDragging) return;
        const newLeft = startLeft + (e.clientX - startX);
        const newTop = startTop + (e.clientY - startY);
        
        element.style.left = newLeft + "px";
        element.style.top = newTop + "px";
        
        // Move drawing canvas with the image
        const drawingCanvas = element.nextElementSibling;
        if (drawingCanvas && drawingCanvas.classList.contains('drawing-canvas')) {
            drawingCanvas.style.left = newLeft + "px";
            drawingCanvas.style.top = newTop + "px";
        }
    }

    function stopDrag(e) {
    isDragging = false;
    document.removeEventListener('mousemove', dragMove);
    document.removeEventListener('mouseup', stopDrag);

    // Check if image overlaps a template box
    const templateBoxes = document.querySelectorAll('.template-box');
    const imageRect = element.getBoundingClientRect();

    for (const box of templateBoxes) {
        const boxRect = box.getBoundingClientRect();

        const isOverlapping = !(
            imageRect.right < boxRect.left ||
            imageRect.left > boxRect.right ||
            imageRect.bottom < boxRect.top ||
            imageRect.top > boxRect.bottom
        );

        if (isOverlapping) {
            // Snap to template box position
            const containerRect = collageContainer.getBoundingClientRect();
            element.style.left = (boxRect.left - containerRect.left) + 'px';
            element.style.top = (boxRect.top - containerRect.top) + 'px';

            // Resize image to match template box
            const boxWidth = box.offsetWidth;
            const boxHeight = box.offsetHeight;
            resizeImageToBox(element, boxWidth, boxHeight);

            // Move drawing canvas too
            const drawingCanvas = element.nextElementSibling;
            if (drawingCanvas && drawingCanvas.classList.contains('drawing-canvas')) {
                drawingCanvas.style.left = element.style.left;
                drawingCanvas.style.top = element.style.top;
                // Save current drawing
const tempCanvas = document.createElement('canvas');
tempCanvas.width = drawingCanvas.width;
tempCanvas.height = drawingCanvas.height;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.drawImage(drawingCanvas, 0, 0);

// Resize the drawing canvas
drawingCanvas.width = boxWidth;
drawingCanvas.height = boxHeight;
drawingCanvas.style.width = boxWidth + 'px';
drawingCanvas.style.height = boxHeight + 'px';

// Redraw preserved drawing, scaled
const ctx = drawingCanvas.getContext('2d');
ctx.clearRect(0, 0, boxWidth, boxHeight);
ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, boxWidth, boxHeight);

            }

            break; // Only apply to first matching box
        }
    }
}

}

    function applyFilter(filterType) {
        if (!selectedImage) return;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = selectedImage.naturalWidth;
        canvas.height = selectedImage.naturalHeight;

        ctx.drawImage(selectedImage, 0, 0, canvas.width, canvas.height);

        switch (filterType) {
            case 'grayscale':
                ctx.filter = "grayscale(100%)";
                break;
            case 'sepia':
                ctx.filter = "sepia(100%)";
                break;
            case 'blur':
                ctx.filter = "blur(5px)";
                break;
            default:
                console.error("Invalid filter type");
                return;
        }

        ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height);
        selectedImage.src = canvas.toDataURL();
    }

    function selectImage(img) {
    if (selectedImage) {
        selectedImage.classList.remove('selected');
        disableResize();
        disableTilt();
        disableDrawing();
        disableEraser();
    }
    
    selectedImage = img;
    img.classList.add('selected');
    
    // Ensure we have current values
    if (typeof currentColor === 'undefined') {
        currentColor = document.getElementById('drawingColor').value;
    }
    if (typeof brushSize === 'undefined') {
        brushSize = parseInt(document.getElementById('brushSize').value);
    }
    
    // Find or create drawing canvas
    let drawingCanvas = img.nextElementSibling;
    if (!drawingCanvas || !drawingCanvas.classList.contains('drawing-canvas')) {
        drawingCanvas = document.createElement('canvas');
        drawingCanvas.className = 'drawing-canvas';
        drawingCanvas.width = img.offsetWidth;
        drawingCanvas.height = img.offsetHeight;
        img.parentNode.insertBefore(drawingCanvas, img.nextSibling);
        
        drawingCanvas.style.position = 'absolute';
        drawingCanvas.style.left = img.style.left;
        drawingCanvas.style.top = img.style.top;
        drawingCanvas.style.width = img.style.width;
        drawingCanvas.style.height = img.style.height;
        drawingCanvas.style.pointerEvents = 'none';
    }
    
    // Initialize drawing context with current settings
    currentDrawingCtx = drawingCanvas.getContext('2d');
    currentDrawingCtx.strokeStyle = currentColor;
    currentDrawingCtx.lineWidth = brushSize;
    currentDrawingCtx.lineJoin = 'round';
    currentDrawingCtx.lineCap = 'round';
    currentDrawingCanvas = drawingCanvas;
    
    updateBrushSettings();
}
    function rotateSelected(angle) {
        if (!selectedImage) return;
        let rotation = parseInt(selectedImage.dataset.rotation) || 0;
        rotation = (rotation + angle) % 360;
        selectedImage.dataset.rotation = rotation;
        applyTransformations(selectedImage);
    }

    function flipSelected(axis) {
        if (!selectedImage) return;
        if (axis === 'X') {
            selectedImage.dataset.flipX *= -1;
        } else {
            selectedImage.dataset.flipY *= -1;
        }
        applyTransformations(selectedImage);
    }

  


  



    function enableResize() {
    if (!selectedImage) {
        alert("Please select an image first");
        return;
    }
    
    if (isResizingEnabled) {
        disableResize();
        return;
    }
    
    // Disable other modes
    if (isTiltingEnabled) disableTilt();
    if (isCropping) resetCrop();
    if (isDrawingEnabled) disableDrawing();
    if (isEraserEnabled) disableEraser();
    
    // Create four resize handles
    const handlePositions = [
        { class: 'nw', cursor: 'nw-resize' },
        { class: 'ne', cursor: 'ne-resize' },
        { class: 'sw', cursor: 'sw-resize' },
        { class: 'se', cursor: 'se-resize' }
    ];
    
    // Create a container for the handles
    const handlesContainer = document.createElement('div');
    handlesContainer.className = 'resize-handles-container';
    handlesContainer.style.position = 'absolute';
    
    // Get initial position and dimensions
    const imgRect = selectedImage.getBoundingClientRect();
    const containerRect = collageContainer.getBoundingClientRect();
    
    const left = imgRect.left - containerRect.left;
    const top = imgRect.top - containerRect.top;
    const width = imgRect.width;
    const height = imgRect.height;
    
    // Apply the same transform as the image
    const transform = window.getComputedStyle(selectedImage).transform;
    
    handlesContainer.style.left = left + 'px';
    handlesContainer.style.top = top + 'px';
    handlesContainer.style.width = width + 'px';
    handlesContainer.style.height = height + 'px';
    handlesContainer.style.transform = transform !== 'none' ? transform : '';
    handlesContainer.style.transformOrigin = 'center center';
    handlesContainer.style.pointerEvents = 'none';
    
    collageContainer.appendChild(handlesContainer);
    
    handlePositions.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos.class}`;
        handle.style.cursor = pos.cursor;
        handle.dataset.direction = pos.class;
        handle.style.pointerEvents = 'auto';
        
        // Position the handle
        if (pos.class.includes('n')) handle.style.top = '0px';
        if (pos.class.includes('s')) handle.style.bottom = '0px';
        if (pos.class.includes('w')) handle.style.left = '0px';
        if (pos.class.includes('e')) handle.style.right = '0px';
        
        handlesContainer.appendChild(handle);
        resizeHandles.push(handle);
        
        handle.addEventListener('mousedown', function(e) {
            e.stopPropagation();
            e.preventDefault();
            startResize(e, pos.class);
        });
    });
    
    // Update container position when image moves or transforms
    const observer = new MutationObserver(() => {
        const imgRect = selectedImage.getBoundingClientRect();
        const containerRect = collageContainer.getBoundingClientRect();
        
        const left = imgRect.left - containerRect.left;
        const top = imgRect.top - containerRect.top;
        const width = imgRect.width;
        const height = imgRect.height;
        const transform = window.getComputedStyle(selectedImage).transform;
        
        const container = document.querySelector('.resize-handles-container');
        if (container) {
            container.style.left = left + 'px';
            container.style.top = top + 'px';
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            container.style.transform = transform !== 'none' ? transform : '';
        }
    });
    
    resizeHandles.observer = observer;
    observer.observe(selectedImage, { 
        attributes: true,
        attributeFilter: ['style']
    });
    
    isResizingEnabled = true;
}

function startResize(e, direction) {
    e.stopPropagation();
    e.preventDefault();
    
    isResizing = true;
    resizeDirection = direction;
    
    startX = e.clientX;
    startY = e.clientY;
    
    // Get initial dimensions from computed style (ignores transforms)
    const computedStyle = window.getComputedStyle(selectedImage);
    startWidth = parseFloat(computedStyle.width);
    startHeight = parseFloat(computedStyle.height);
    startLeft = parseFloat(selectedImage.style.left) || 0;
    startTop = parseFloat(selectedImage.style.top) || 0;
    
    // Store aspect ratio
    resizeHandles.aspectRatio = startWidth / startHeight;
    
    // Add event listeners
    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', stopResize);
    
    // Prevent text selection during resize
    document.body.style.userSelect = 'none';
}

function doResize(e) {
    if (!isResizing) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    // Get current dimensions from computed style (ignores transforms)
    const computedStyle = window.getComputedStyle(selectedImage);
    let newWidth = parseFloat(computedStyle.width);
    let newHeight = parseFloat(computedStyle.height);
    let newLeft = parseFloat(selectedImage.style.left) || 0;
    let newTop = parseFloat(selectedImage.style.top) || 0;
    
    const maintainAspect = e.shiftKey;
    const aspectRatio = startWidth / startHeight;
    
    // Calculate changes based on direction
    switch(resizeDirection) {
        case 'nw':
            newWidth = Math.max(50, startWidth - dx);
            if (maintainAspect) newHeight = newWidth / aspectRatio;
            else newHeight = Math.max(50, startHeight - dy);
            newLeft = startLeft + (startWidth - newWidth);
            newTop = startTop + (startHeight - newHeight);
            break;
        case 'ne':
            newWidth = Math.max(50, startWidth + dx);
            if (maintainAspect) newHeight = newWidth / aspectRatio;
            else newHeight = Math.max(50, startHeight - dy);
            newTop = startTop + (startHeight - newHeight);
            break;
        case 'sw':
            newWidth = Math.max(50, startWidth - dx);
            if (maintainAspect) newHeight = newWidth / aspectRatio;
            else newHeight = Math.max(50, startHeight + dy);
            newLeft = startLeft + (startWidth - newWidth);
            break;
        case 'se':
            newWidth = Math.max(50, startWidth + dx);
            if (maintainAspect) newHeight = newWidth / aspectRatio;
            else newHeight = Math.max(50, startHeight + dy);
            break;
    }
    
    // Apply new dimensions to image
    selectedImage.style.width = newWidth + 'px';
    selectedImage.style.height = newHeight + 'px'; // Changed from 'auto' to fixed height
    
    // Update position if needed
    if (resizeDirection === 'nw' || resizeDirection === 'sw') {
        selectedImage.style.left = newLeft + 'px';
    }
    if (resizeDirection === 'nw' || resizeDirection === 'ne') {
        selectedImage.style.top = newTop + 'px';
    }
    
    // Update drawing canvas
    const drawingCanvas = selectedImage.nextElementSibling;
    if (drawingCanvas && drawingCanvas.classList.contains('drawing-canvas')) {
        // Save current transformation matrix
        const transform = window.getComputedStyle(selectedImage).transform;
        const transformOrigin = window.getComputedStyle(selectedImage).transformOrigin;
        
        // Create temp canvas with original content
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = drawingCanvas.width;
        tempCanvas.height = drawingCanvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(drawingCanvas, 0, 0);
        
        // Resize the drawing canvas
        drawingCanvas.width = newWidth;
        drawingCanvas.height = newHeight;
        const ctx = drawingCanvas.getContext('2d');
        
        // Clear and redraw with proper scaling
        ctx.clearRect(0, 0, newWidth, newHeight);
        ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, newWidth, newHeight);
        
        // Update canvas style properties
        drawingCanvas.style.width = newWidth + 'px';
        drawingCanvas.style.height = newHeight + 'px';
        drawingCanvas.style.left = selectedImage.style.left;
        drawingCanvas.style.top = selectedImage.style.top;
        
        // Reapply transformations
        drawingCanvas.style.transform = transform;
        drawingCanvas.style.transformOrigin = transformOrigin;
    }
    
    // Update handles container
    const handlesContainer = document.querySelector('.resize-handles-container');
    if (handlesContainer) {
        handlesContainer.style.left = selectedImage.style.left;
        handlesContainer.style.top = selectedImage.style.top;
        handlesContainer.style.width = newWidth + 'px';
        handlesContainer.style.height = newHeight + 'px';
    }
    
    // Force redraw of the yellow border
    selectedImage.classList.remove('selected');
    void selectedImage.offsetWidth; // Trigger reflow
    selectedImage.classList.add('selected');
}

function stopResize() {
    if (!isResizing) return;
    
    isResizing = false;
    resizeDirection = null;
    
    // Remove event listeners
    document.removeEventListener('mousemove', doResize);
    document.removeEventListener('mouseup', stopResize);
    
    // Restore text selection
    document.body.style.userSelect = '';
}
function disableResize() {
    if (!isResizingEnabled) return;
    
    // Remove all resize handles and containers
    const containers = document.querySelectorAll('.resize-handles-container');
    containers.forEach(container => {
        if (container.parentNode) {
            container.parentNode.removeChild(container);
        }
    });
    
    // Disconnect observer if it exists
    if (resizeHandles.observer) {
        resizeHandles.observer.disconnect();
        delete resizeHandles.observer;
    }
    
    // Clear resize handles array
    resizeHandles = [];
    isResizingEnabled = false;
    
    // Ensure any active resize is stopped
    stopResize();
    
    // Reset cursor
    document.body.style.cursor = '';
}
let isTiltingEnabled = false;
let tiltHandles = [];
let isTilting = false;
let tiltDirection = null;
let tiltStartX, tiltStartY;
let currentSkewX = 0;
let currentSkewY = 0;

function enableTilt() {
    if (!selectedImage) {
        alert("Please select an image first");
        return;
    }
    
    if (isTiltingEnabled) {
        disableTilt();
        return;
    }
    
    // Disable other modes if active
    if (isResizingEnabled) disableResize();
    if (isCropping) resetCrop();
    if (isDrawingEnabled) disableDrawing();
    if (isEraserEnabled) disableEraser();
    
    // Create four tilt handles (top, right, bottom, left)
    const handlePositions = [
        { class: 'top', cursor: 'ns-resize' },
        { class: 'right', cursor: 'ew-resize' },
        { class: 'bottom', cursor: 'ns-resize' },
        { class: 'left', cursor: 'ew-resize' }
    ];
    
    // Create a container for the handles
    const handlesContainer = document.createElement('div');
    handlesContainer.className = 'tilt-handles-container';
    handlesContainer.style.position = 'absolute';
    handlesContainer.style.left = selectedImage.style.left;
    handlesContainer.style.top = selectedImage.style.top;
    handlesContainer.style.width = selectedImage.offsetWidth + 'px';
    handlesContainer.style.height = selectedImage.offsetHeight + 'px';
    handlesContainer.style.pointerEvents = 'none';
    
    collageContainer.appendChild(handlesContainer);
    
    handlePositions.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `tilt-handle ${pos.class}`;
        handle.style.cursor = pos.cursor;
        handle.dataset.direction = pos.class;
        handle.style.pointerEvents = 'auto';
        
        handlesContainer.appendChild(handle);
        tiltHandles.push(handle);
        
        // Handle mouse events
        handle.addEventListener('mousedown', function(e) {
            e.stopPropagation();
            e.preventDefault();
            startTilt(e, pos.class);
        });
    });
    
    // Update container position when image moves
    const observer = new MutationObserver(() => {
        handlesContainer.style.left = selectedImage.style.left;
        handlesContainer.style.top = selectedImage.style.top;
        handlesContainer.style.width = selectedImage.offsetWidth + 'px';
        handlesContainer.style.height = selectedImage.offsetHeight + 'px';
    });
    
    tiltHandles.observer = observer;
    observer.observe(selectedImage, { 
        attributes: true,
        attributeFilter: ['style']
    });
    
    isTiltingEnabled = true;
}

function startTilt(e, direction) {
    e.stopPropagation();
    e.preventDefault();
    
    isTilting = true;
    tiltDirection = direction;
    tiltStartX = e.clientX;
    tiltStartY = e.clientY;
    
    // Store current skew values
    const transform = selectedImage.style.transform || '';
    const skewXMatch = transform.match(/skewX\(([-\d.]+)deg\)/);
    const skewYMatch = transform.match(/skewY\(([-\d.]+)deg\)/);
    
    currentSkewX = skewXMatch ? parseFloat(skewXMatch[1]) : 0;
    currentSkewY = skewYMatch ? parseFloat(skewYMatch[1]) : 0;
    
    // Add event listeners
    document.addEventListener('mousemove', doTilt);
    document.addEventListener('mouseup', stopTilt);
    
    // Prevent text selection during tilt
    document.body.style.userSelect = 'none';
}

function doTilt(e) {
    if (!isTilting) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    const dx = e.clientX - tiltStartX;
    const dy = e.clientY - tiltStartY;
    
    let newSkewX = currentSkewX;
    let newSkewY = currentSkewY;
    
    // Adjust skew based on direction
    switch(tiltDirection) {
        case 'top':
            newSkewY = currentSkewY + (dx * 0.2);
            break;
        case 'right':
            newSkewX = currentSkewX + (dy * 0.2);
            break;
        case 'bottom':
            newSkewY = currentSkewY - (dx * 0.2);
            break;
        case 'left':
            newSkewX = currentSkewX - (dy * 0.2);
            break;
    }
    
    // Limit skew to reasonable values
    newSkewX = Math.max(-45, Math.min(45, newSkewX));
    newSkewY = Math.max(-45, Math.min(45, newSkewY));
    
    // Apply the skew transformation
    applyTransformations(selectedImage, newSkewX, newSkewY);
}

function stopTilt() {
    if (!isTilting) return;
    
    isTilting = false;
    tiltDirection = null;
    
    // Remove event listeners
    document.removeEventListener('mousemove', doTilt);
    document.removeEventListener('mouseup', stopTilt);
    
    // Restore text selection
    document.body.style.userSelect = '';
}

function disableTilt() {
    // Remove all tilt handles
    const containers = document.querySelectorAll('.tilt-handles-container');
    containers.forEach(container => {
        if (container.parentNode) {
            container.parentNode.removeChild(container);
        }
    });
    
    // Disconnect observer if it exists
    if (tiltHandles.observer) {
        tiltHandles.observer.disconnect();
    }
    
    // Clear tilt handles array
    tiltHandles = [];
    isTiltingEnabled = false;
    
    // Ensure any active tilt is stopped
    stopTilt();
}

function applyTransformations(img, skewX = null, skewY = null) {
    const rotation = img.dataset.rotation || 0;
    const flipX = img.dataset.flipX || 1;
    const flipY = img.dataset.flipY || 1;
    
    // Use provided skew values or parse from current transform
    if (skewX === null || skewY === null) {
        const transform = img.style.transform || '';
        const skewXMatch = transform.match(/skewX\(([-\d.]+)deg\)/);
        const skewYMatch = transform.match(/skewY\(([-\d.]+)deg\)/);
        
        skewX = skewXMatch ? parseFloat(skewXMatch[1]) : 0;
        skewY = skewYMatch ? parseFloat(skewYMatch[1]) : 0;
    }
    
    img.style.transform = `
        rotate(${rotation}deg) 
        scale(${flipX}, ${flipY}) 
        skewX(${skewX}deg) 
        skewY(${skewY}deg)
    `.trim();
    
    // Apply same transformations to drawing canvas
    const drawingCanvas = img.nextElementSibling;
    if (drawingCanvas && drawingCanvas.classList.contains('drawing-canvas')) {
        // Preserve the current drawing content
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = drawingCanvas.width;
        tempCanvas.height = drawingCanvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(drawingCanvas, 0, 0);
        
        // Apply transformations
        drawingCanvas.style.transform = `
            rotate(${rotation}deg) 
            scale(${flipX}, ${flipY}) 
            skewX(${skewX}deg) 
            skewY(${skewY}deg)
        `.trim();
        
        // Restore the drawing content
        const ctx = drawingCanvas.getContext('2d');
        ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        ctx.drawImage(tempCanvas, 0, 0);
        
        // Restore brush settings
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = brushSize;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
    }
}
    function deleteSelectedImage() {
    if (!selectedImage) return;
    disableTilt();
    
    // Find and remove the associated drawing canvas
    const drawingCanvas = selectedImage.nextElementSibling;
    if (drawingCanvas && drawingCanvas.classList.contains('drawing-canvas')) {
        collageContainer.removeChild(drawingCanvas);
    }
    
    // Remove the image
    collageContainer.removeChild(selectedImage);
    selectedImage = null;
    disableResize();
}
    function bakeAllSliderFilters(image) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = image.naturalWidth;
        canvas.height = image.naturalHeight;

        const brightness = document.getElementById('brightnessSlider').value || 100;
        const contrast = document.getElementById('contrastSlider').value || 100;
        const saturation = document.getElementById('saturationSlider').value || 100;

        ctx.filter = `
            brightness(${brightness}%)
            contrast(${contrast}%)
            saturate(${saturation}%)
        `;

        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        image.src = canvas.toDataURL();
        image.style.filter = '';
    }

    const { ipcRenderer } = require('electron');
    const fs = require('fs');

    function downloadCollage() {
    // First check if there are any images
    const images = collageContainer.querySelectorAll('img');
    if (images.length === 0) {
        ipcRenderer.send("show-error-dialog", {
            title: "Save Error",
            message: "Please add at least one image to the collage before saving."
        });
        return;
    }

    // Create a clone of the entire collage container
    const containerClone = collageContainer.cloneNode(true);
    
    // Remove selection borders from all images
    containerClone.querySelectorAll('.selected').forEach(el => {
        el.classList.remove('selected');
    });

    // Hide any active resize/tilt handles
    containerClone.querySelectorAll('.resize-handles-container, .tilt-handles-container').forEach(el => {
        el.style.display = 'none';
    });

    // Process each image to bake in filters and combine with drawings
    const processPromises = Array.from(containerClone.querySelectorAll('img')).map(img => {
        return new Promise((resolve) => {
            // Create a new image element to ensure it's loaded
            const tempImg = new Image();
            tempImg.crossOrigin = 'Anonymous';
            
            tempImg.onload = () => {
                // Create canvas for the image
                const imgCanvas = document.createElement('canvas');
                const ctx = imgCanvas.getContext('2d');
                
                // Set canvas dimensions to natural image size
                imgCanvas.width = tempImg.naturalWidth;
                imgCanvas.height = tempImg.naturalHeight;
                
                // Apply filters if any
                if (img.style.filter && img.style.filter !== 'none') {
                    ctx.filter = img.style.filter;
                }
                
                // Draw the image
                ctx.drawImage(tempImg, 0, 0, imgCanvas.width, imgCanvas.height);
                
                // Get the drawing canvas if exists
                const drawingCanvas = img.nextElementSibling;
                if (drawingCanvas && drawingCanvas.classList.contains('drawing-canvas')) {
                    // Create a temporary canvas for the drawing
                    const tempDrawCanvas = document.createElement('canvas');
                    const tempDrawCtx = tempDrawCanvas.getContext('2d');
                    
                    // Scale drawing canvas to match image dimensions
                    tempDrawCanvas.width = imgCanvas.width;
                    tempDrawCanvas.height = imgCanvas.height;
                    
                    // Draw the scaled drawing
                    tempDrawCtx.drawImage(
                        drawingCanvas, 
                        0, 0, drawingCanvas.width, drawingCanvas.height,
                        0, 0, tempDrawCanvas.width, tempDrawCanvas.height
                    );
                    
                    // Combine with the image
                    ctx.drawImage(tempDrawCanvas, 0, 0);
                    
                    // Remove the drawing canvas from clone
                    drawingCanvas.remove();
                }
                
                // Replace the image with the combined version
                img.src = imgCanvas.toDataURL();
                img.style.width = img.style.width; // Preserve original display size
                img.style.height = img.style.height;
                img.style.transform = img.style.transform; // Preserve transforms
                
                resolve();
            };
            
            tempImg.onerror = () => {
                console.error("Failed to load image:", img.src);
                resolve(); // Resolve anyway to not block the process
            };
            
            tempImg.src = img.src;
        });
    });

    // After processing all images, capture the entire container
    Promise.all(processPromises).then(() => {
        // Position the clone off-screen
        containerClone.style.position = 'absolute';
        containerClone.style.left = '-9999px';
        containerClone.style.top = '0';
        document.body.appendChild(containerClone);

        // Add slight delay to ensure DOM is ready
        setTimeout(() => {
            html2canvas(containerClone, {
                backgroundColor: null,
                scale: 2, // Higher quality
                logging: false,
                useCORS: true,
                allowTaint: true,
                ignoreElements: (element) => {
                    // Ignore any remaining resize handles or other UI elements
                    return element.classList.contains('resize-handles-container') || 
                           element.classList.contains('tilt-handles-container');
                }
            }).then(canvas => {
                document.body.removeChild(containerClone);
                
                ipcRenderer.send("request-save-dialog");
                
                ipcRenderer.once("save-file-path", (event, { filePath, extension }) => {
                    const mimeMap = {
                        png: 'image/png',
                        jpg: 'image/jpeg',
                        jpeg: 'image/jpeg',
                        webp: 'image/webp',
                        bmp: 'image/bmp',
                        tif: 'image/tiff',
                        tiff: 'image/tiff'
                    };

                    const mime = mimeMap[extension] || 'image/png';

                        canvas.toBlob(blob => {
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                const buffer = Buffer.from(reader.result);
                                fs.writeFile(filePath, buffer, err => {
                                    if (err) {
                                        console.error("Failed to save image:", err);
                                        ipcRenderer.send("show-error-dialog", {
                                            title: "Save Error",
                                            message: "Failed to save the image. Please try again."
                                        });
                                    } else {
                                        console.log("Saved:", filePath);
                                        ipcRenderer.send("show-success-dialog", {
                                            title: "Success",
                                            message: "Collage saved successfully!"
                                        });
                                    }
                                });
                            };
                            reader.readAsArrayBuffer(blob);
                        }, mime);
                });
            }).catch(err => {
                console.error("Error generating collage:", err);
                document.body.removeChild(containerClone);
                ipcRenderer.send("show-error-dialog", {
                    title: "Error",
                    message: "Failed to generate collage. Please try again."
                });
            });
        }, 100);
    });
}
document.addEventListener('keydown', function(e) {
    const key = e.key.toLowerCase();
    const ctrl = e.ctrlKey;
    const shift = e.shiftKey;

    if (ctrl && key === 'h') { e.preventDefault(); goHome(); }
    else if (ctrl && key === 'o') { e.preventDefault(); openImages(); }
    else if (ctrl && key === 's') { e.preventDefault(); downloadCollage(); }
    else if (key === 'delete') { e.preventDefault(); deleteSelectedImage(); }
    else if (key === 'c') { e.preventDefault(); cropSelectedImage(); }
    else if (key === 'l' && !shift) { e.preventDefault(); rotateSelected(-90); }
    else if (key === 'l' && shift) { e.preventDefault(); rotateSelected(90); }
    else if (key === 'f') { e.preventDefault(); flipSelected('X'); }
    else if (key === 'v') { e.preventDefault(); flipSelected('Y'); }
    else if (key === 't') { e.preventDefault(); enableTilt(); }
    else if (key === 'g') { e.preventDefault(); applyFilter('grayscale'); }
    else if (key === 'e') { e.preventDefault(); applyFilter('sepia'); }
    else if (key === 'b') { e.preventDefault(); applyFilter('blur'); }
});

</script>
</body>
</html>
